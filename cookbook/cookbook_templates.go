// DBDeployer - The MySQL Sandbox
// Copyright Â© 2006-2019 Giuseppe Maxia
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package cookbook

import "github.com/datacharmer/dbdeployer/common"

type RecipeTemplate struct {
	Description    string
	ScriptName     string
	Notes          string
	Contents       string
	RequiredFlavor string
	IsExecutable   bool
}

type RecipesCollection map[string]RecipeTemplate

const (
	CookbookInclude       = "cookbook_include.sh"
	CookbookPrerequisites = "prerequisites.sh"
)

var recipeInclude string = `
if [ -z "$SANDBOX_HOME" ]
then
    export SANDBOX_HOME=$HOME/sandboxes
fi

if [ -z "$SANDBOX_BINARY" ]
then
    export SANDBOX_BINARY=$HOME/opt/mysql
fi

function check_version {
    wanted_version=$1
    check_upgrade=$2
    invalid_version=$(echo $wanted_version| grep NOTFOUND)
    if [ -z "$wanted_version" -o -n "$invalid_version" ]
    then
        echo "No version provided"
        exit 1
    fi

    if [ ! -d $SANDBOX_BINARY/$wanted_version ]
    then
        echo "Directory $SANDBOX_BINARY/$wanted_version not found"
        echo "To install the binaries, use: "
        echo "    dbdeployer unpack mysql-$version-YOUR-OPERATING-SYSTEM.tar.gz"
        exit 1
    fi
    if [ -z "$check_upgrade" ]
    then
        return
    fi
    if [ ! -x $SANDBOX_BINARY/$wanted_version/bin/mysql_upgrade ]
    then
        echo "mysql_upgrade not found in $wanted_version"
        exit 1
    fi
    version_path=$(echo msb_$wanted_version | tr '.' '_')
    if [ -d $SANDBOX_HOME/$version_path ]
    then
        echo "Version $wanted_version is already installed in $SANDBOX_HOME/$version_path"
        exit 1
    fi
}

dash_line="# ----------------------------------------------------------------------------"
star_line="# ****************************************************************************"
hash_line="# ############################################################################"

function header {
    msg="$1"
    msg2="$2"
    msg3="$3"
    echo ""
    echo "$star_line"
    echo "# $msg"
    if [ -n "$msg2" ] ; then echo "# $msg2" ; fi
    if [ -n "$msg3" ] ; then echo "# $msg3" ; fi
    echo "$star_line"
}`

var singleTemplate string = `#!/bin/bash
{{.Copyright}}
# Generated by dbdeployer {{.AppVersion}} using template {{.TemplateName}} on {{.DateTime}}
cd $(dirname $0)
source cookbook_include.sh

version=$1
[ -z "$version" ] && version={{.LatestVersion}}
check_version $version


if [ -n "$(dbdeployer sandboxes | grep 'single\s*'$version)" ]
then
    echo "single version $version is already installed"
else
    header "Deploying a single sandbox for version $version"
    (set -x
    dbdeployer deploy single $version
    )
fi
`

var singleReinstallTemplate string = `#!/bin/bash
{{.Copyright}}
# Generated by dbdeployer {{.AppVersion}} using template {{.TemplateName}} on {{.DateTime}}
cd $(dirname $0)
source cookbook_include.sh

version=$1
[ -z "$version" ] && version={{.LatestVersion}}
check_version $version

if [ -z "$(dbdeployer sandboxes | grep 'single\s*'$version)" ]
then
    echo "single version $version is not installed"
    echo "Run './single.sh $version' before trying again"
    exit 1
fi

header "Deploying the same sandbox again, with different parameters" \
       "We need to use --force, as we are overwriting an existing sandbox" \
       "Incidentally, the new deployment will run a query before and after the grants"
(set -x
dbdeployer deploy single $version
dbdeployer deploy single $version --pre-grants-sql='select host, user from mysql.user' \
    --post-grants-sql='select host, user from mysql.user' --force
)

sandbox_dir=msb_$(echo $version | tr '.' '_' )

header "Deploying the same sandbox with a different directory. " \
       "No --force is necessary, as dbdeployer will choose a different port"
(set -x
dbdeployer deploy single $version --sandbox-directory=${sandbox_dir}_new
)
echo ""
(set -x
dbdeployer sandboxes --header
)

header "Removing the second sandbox"
(set -x
dbdeployer delete ${sandbox_dir}_new
)
`

var showSandboxes string = `#!/bin/bash
{{.Copyright}}
# Generated by dbdeployer {{.AppVersion}} using template {{.TemplateName}} on {{.DateTime}}
cd $(dirname $0)
source cookbook_include.sh

(set -x
dbdeployer sandboxes --full-info
)

# Alternative:
#(set -x
#dbdeployer sandboxes --header --catalog
#)
`
var deleteAll string = `#!/bin/bash
{{.Copyright}}
# Generated by dbdeployer {{.AppVersion}} using template {{.TemplateName}} on {{.DateTime}}
cd $(dirname $0)
source cookbook_include.sh

echo "WARNING: This script deletes all installed sandboxes"
(set -x
dbdeployer delete all --concurrent
)
# you can also skip manual confirmation:
# dbdeployer delete all --concurrent --skip-confirm
`

var masterSlaveDeployment string = `#!/bin/bash
{{.Copyright}}
# Generated by dbdeployer {{.AppVersion}} using template {{.TemplateName}} on {{.DateTime}}
cd $(dirname $0)
source cookbook_include.sh
version=$1
[ -z "$version" ] && version={{.LatestVersion}}
check_version $version

if [ -n "$(dbdeployer sandboxes | grep 'master-slave\s*'$version)" ]
then
    echo "replication version $version is already installed"
else
    (set -x
    dbdeployer deploy replication $version --concurrent
    )
fi
`
var fanInDeployment string = `#!/bin/bash
{{.Copyright}}
# Generated by dbdeployer {{.AppVersion}} using template {{.TemplateName}} on {{.DateTime}}
cd $(dirname $0)
source cookbook_include.sh

version=$1
[ -z "$version" ] && version={{.LatestVersion}}
check_version $version

if [ -n "$(dbdeployer sandboxes | grep 'fan-in\s*'$version)" ]
then
    echo "fan-in replication version $version is already installed"
else
    (set -x
    dbdeployer deploy replication $version --topology=fan-in --concurrent
    )
fi
`
var allMastersDeployment string = `#!/bin/bash
{{.Copyright}}
# Generated by dbdeployer {{.AppVersion}} using template {{.TemplateName}} on {{.DateTime}}
cd $(dirname $0)
source cookbook_include.sh
version=$1
[ -z "$version" ] && version={{.LatestVersion}}
check_version $version

if [ -n "$(dbdeployer sandboxes | grep 'all-masters\s*'$version)" ]
then
    echo "all-masters replication version $version is already installed"
else
    (set -x
    dbdeployer deploy replication $version --topology=all-masters --concurrent
    )
fi
`
var groupMultiPrimaryDeployment string = `#!/bin/bash
{{.Copyright}}
# Generated by dbdeployer {{.AppVersion}} using template {{.TemplateName}} on {{.DateTime}}
cd $(dirname $0)
source cookbook_include.sh

version=$1
[ -z "$version" ] && version={{.LatestVersion}}
check_version $version

if [ -n "$(dbdeployer sandboxes | grep 'group-multi-primary\s*'$version)" ]
then
    echo "group replication version $version is already installed"
else
    (set -x
    dbdeployer deploy replication $version --topology=group --concurrent
    )
fi
`
var groupSinglePrimaryDeployment string = `#!/bin/bash
{{.Copyright}}
# Generated by dbdeployer {{.AppVersion}} using template {{.TemplateName}} on {{.DateTime}}
cd $(dirname $0)
source cookbook_include.sh

version=$1
[ -z "$version" ] && version={{.LatestVersion}}
check_version $version

if [ -n "$(dbdeployer sandboxes | grep 'group-single-primary\s*'$version)" ]
then
    echo "group replication (single primary) version $version is already installed"
else
    (set -x
    dbdeployer deploy replication $version --topology=group --single-primary --concurrent
    )
fi
`

var replicationRestart string = `#!/bin/bash
{{.Copyright}}
# Generated by dbdeployer {{.AppVersion}} using template {{.TemplateName}} on {{.DateTime}}
cd $(dirname $0)
source cookbook_include.sh

version=$1
[ -z "$version" ] && version={{.LatestVersion}}
check_version $version

if [ -z "$(dbdeployer sandboxes | grep 'master-slave\s*'$version)" ]
then
    echo "master-slave version $version is not installed"
    echo "Run './master-slave-deployment.sh $version' before trying again"
    exit 1
fi

sandbox_dir=$SANDBOX_HOME/rsandbox_$(echo $version | tr '.' '_' )

header "Checking the value for max-connections in all nodes"
(set -x
$sandbox_dir/use_all 'select @@max_connections'
)

header "Restarting all nodes with the new value"
(set -x
$sandbox_dir/restart_all --max-connections=66
)

header "Checking the new value for max-connections in all nodes"
(set -x
$sandbox_dir/use_all 'select @@max_connections'
)

header "Restarting slave #2 without specifying any values."
(set -x
$sandbox_dir/node2/restart
)

header "Checking the value for max-connections in all nodes: node #2 has again the default value"
(set -x
$sandbox_dir/use_all 'select @@max_connections'
)

header "Adding a custom number of connection permanently to slave #2 ( NOTE: no dashes! )"
(set -x
$sandbox_dir/node2/add_option max-connections=99
)

header "Restarting slave #2 without specifying any values. We'll see that its own value is preserved"
(set -x
$sandbox_dir/node2/restart
)

header "Checking the value for max-connections in all nodes: node #2 has kept its own value"
(set -x
$sandbox_dir/use_all 'select @@max_connections'
)
`

var replicationOperations string = `#!/bin/bash
{{.Copyright}}
# Generated by dbdeployer {{.AppVersion}} using {{.TemplateName}} on {{.DateTime}}
cd $(dirname $0)
source cookbook_include.sh

version=$1
[ -z "$version" ] && version={{.LatestVersion}}
check_version $version

if [ -z "$(dbdeployer sandboxes | grep 'master-slave\s*'$version)" ]
then
    echo "master-slave version $version is not installed"
    echo "Run './master-slave-deployment.sh $version' before trying again"
    exit 1
fi

sandbox_dir=$SANDBOX_HOME/rsandbox_$(echo $version | tr '.' '_' )

header "Running a simple command with the master in the sandbox." \
   "Notice the usage of the '-e', as if we were using the 'mysql' client" 

(set -x
$sandbox_dir/m -e 'SHOW MASTER STATUS'
)

header "Creating a table in the master"
(set -x
$sandbox_dir/m -e 'DROP TABLE IF EXISTS test.t1'
$sandbox_dir/m -e 'CREATE TABLE test.t1(id int not null primary key)'
)

header "Inserting 3 lines into the new table"
for N in 1 2 3
do
    (set -x
    $sandbox_dir/m -e "INSERT INTO test.t1 VALUES($N)"
    )
done
sleep 2

header "Getting the table contents from one slave"
(set -x
$sandbox_dir/s1 -e "SELECT * FROM test.t1"
)


header "Getting the table count from all nodes (NOTE: no '-e' is needed)"
(set -x
$sandbox_dir/use_all "SELECT COUNT(*) FROM test.t1"
)

header "Checking the status of all slaves"
(set -x
$sandbox_dir/check_slaves
)

header "Running a multiple query in all slaves"
(set -x
$sandbox_dir/use_all_slaves "STOP SLAVE; SET GLOBAL slave_parallel_workers=3; START SLAVE;show processlist "
)
`
var upgradeTemplate string = `#!/bin/bash
{{.Copyright}}
# Generated by dbdeployer {{.AppVersion}} using template {{.TemplateName}} on {{.DateTime}}
cd $(dirname $0)
source cookbook_include.sh

function upgrade_db {
    UPGRADE_FROM=$1
    UPGRADE_TO=$2

    upgrade_from_dir=msb_$(echo $UPGRADE_FROM | tr '.' '_')
    upgrade_to_dir=msb_$(echo $UPGRADE_TO | tr '.' '_')

    if [ ! -d $SANDBOX_HOME/$upgrade_from_dir ]
    then
        ( set -x 
        dbdeployer deploy single $UPGRADE_FROM --master
        )
    fi
    if [ ! -d $SANDBOX_HOME/$upgrade_to_dir ]
    then
        (set -x 
        dbdeployer deploy single $UPGRADE_TO --master
        )
    fi
    (set -x
    $SANDBOX_HOME/$upgrade_from_dir/use -e "CREATE TABLE IF NOT EXISTS test.upgrade_log(id int not null auto_increment primary key, server_id int, vers varchar(50), urole varchar(20), ts timestamp)"
    $SANDBOX_HOME/$upgrade_from_dir/use -e "INSERT INTO test.upgrade_log (server_id, vers, urole) VALUES (@@server_id, @@version, 'original')"
    dbdeployer admin upgrade $upgrade_from_dir $upgrade_to_dir
    )
    if [ ! -f $upgrade_to_dir/no_upgrade ]
    then
        (set -x
        dbdeployer delete $upgrade_from_dir
        $SANDBOX_HOME/$upgrade_to_dir/use -e "INSERT INTO test.upgrade_log (server_id, vers, urole) VALUES (@@server_id, @@version, 'upgraded')"
        $SANDBOX_HOME/$upgrade_to_dir/use -e "SELECT * FROM test.upgrade_log"
        )
    fi
}

ver_55={{.Latest5_5}}
ver_56={{.Latest5_6}}
ver_57={{.Latest5_7}}
ver_80={{.Latest8_0}}

for ver in $ver_55 $ver_56 $ver_57 $ver_80
do
    check_version $ver check_upgrade
done

header "Upgrading from $ver_55 to $ver_56"
upgrade_db $ver_55 $ver_56
header "The upgraded database is now upgrading from $ver_56 to $ver_57 "
upgrade_db $ver_56 $ver_57
header "The further upgraded database is now upgrading from $ver_57 to $ver_80"
upgrade_db $ver_57 $ver_80

`
var tidbDeployment string = `#!/bin/bash
{{.Copyright}}
# Generated by dbdeployer {{.AppVersion}} using template {{.TemplateName}} on {{.DateTime}}
cd $(dirname $0)
source cookbook_include.sh

tidb_version={{.LatestVersion}}
tidb_postfix=$(echo $tidb_version | tr '.' '_')
client_version={{.Latest5_7}}
single_path=msb_$tidb_postfix
multiple_path=multi_msb_$tidb_postfix
if [ ! -d $SANDBOX_BINARY/$tidb_version ]
then
    echo "Get tidb from one of these URLs" 
    echo "wget https://download.pingcap.org/tidb-master-darwin-amd64.tar.gz"
    echo "wget https://download.pingcap.org/tidb-master-linux-amd64.tar.gz"
    exit 1
fi

if [ ! -d $SANDBOX_BINARY/$client_version ]
then
    echo "You need MySQL $client_version unpacked in $SANDBOX_BINARY" 
    exit 1
fi

deploy_single=yes
deploy_multi=yes
if [ -d $SANDBOX_HOME/$single_path ]
then
    echo "single TiDB already installed in $SANDBOX_HOME/$single_path"
    deploy_single=
fi

if [ -d $SANDBOX_HOME/$multiple_path ]
then
    echo "multiple TiDB already installed in $SANDBOX_HOME/$multiple_path"
    deploy_multi=
fi

if [ "$deploy_single" == "yes" ]
then
    dbdeployer deploy single $tidb_version --client-from=$client_version
fi

if [ "$deploy_multi" == "yes" ]
then
    dbdeployer deploy multiple $tidb_version --client-from=$client_version
fi

$SANDBOX_HOME/$single_path/test_sb
$SANDBOX_HOME/$multiple_path/test_sb_all
`
var remoteOperations string = `#!/bin/bash
{{.Copyright}}
# Generated by dbdeployer {{.AppVersion}} using template {{.TemplateName}} on {{.DateTime}}
cd $(dirname $0)
source cookbook_include.sh

( set -x 
dbdeployer remote list
)

os=$(uname -s | tr 'A-Z' 'a-z')
if [ "$os" != "linux" ]
then
    echo ""
	echo "remote tarballs are only available for Linux"
	exit 1
fi

version=$1
if [ -z "$version" ] 
then
    echo ""
	echo "Syntax $0 version"
	exit 1
fi

( set -x 
dbdeployer remote get mysql-$version
)
if [ ! -f mysql-${version}.tar.xz ]
then
	echo "error downloading mysql-${version}.tar.xz"
	exit 1
fi

dbdeployer unpack ./mysql-${version}.tar.xz
`

var ndbDeployment string = `#!/bin/bash
{{.Copyright}}
# Generated by dbdeployer {{.AppVersion}} using template {{.TemplateName}} on {{.DateTime}}
recipes_dir=$(dirname $0)
cd $recipes_dir
source cookbook_include.sh

version=$1
[ -z "$version" ] && version={{.LatestVersion}}
check_version $version

if [ -n "$(dbdeployer sandboxes | grep 'ndb\s*'$version)" ]
then
    echo "ndb replication version $version is already installed"
else
    (set -x
    dbdeployer deploy replication $version --topology=ndb --concurrent
    )
fi
`
var pxcDeployment string = `#!/bin/bash
{{.Copyright}}
# Generated by dbdeployer {{.AppVersion}} using template {{.TemplateName}} on {{.DateTime}}
recipes_dir=$(dirname $0)
cd $recipes_dir
source cookbook_include.sh

os=$(uname -s | tr 'A-Z' 'a-z')
if [ "$os" != "linux" ]
then
    echo "PXC topology is only available on Linux"
    exit 1
fi

version=$1
[ -z "$version" ] && version={{.LatestVersion}}
check_version $version

if [ -n "$(dbdeployer sandboxes | grep 'pxc\s*'$version)" ]
then
    echo "pxc replication version $version is already installed"
else
    (set -x
    dbdeployer deploy replication $version --topology=pxc --concurrent
    )
fi
`

var prerequisites string = `#!/bin/bash
{{.Copyright}}
# Generated by dbdeployer {{.AppVersion}} using template {{.TemplateName}} on {{.DateTime}}
cd $(dirname $0)
source cookbook_include.sh
os=$(uname -s | tr 'A-Z' 'a-z')

if [ -z "$HOME" ]
then
    echo "Environment variable \$HOME not set"
    echo "nothing will work until this variable is defined"
    exit 1
fi

if [ -d $SANDBOX_BINARY ]
then
    echo "\$SANDBOX_BINARY directory '$SANDBOX_BINARY' exists"
else
    header "Creating Sandbox binary directory ($SANDBOX_BINARY)"
    mkdir -p $SANDBOX_BINARY	
fi

found_versions=$(ls $SANDBOX_BINARY | wc -l | tr -d '\t ' )

function get_prerequisites_linux {
    echo "# FOR REGULAR MYSQL"
    echo "# run the commands: "
    echo ""
    echo "1. dbdeployer remote list"
    echo "2. dbdeployer remote get mysql-5.7.25"
    echo "3. dbdeployer unpack mysql-5.7.25.tar.xz"
    echo ""
    echo "4. dbdeployer versions"
    echo ""
    echo "# FOR MySQL forks, MySQL Cluster, PXC:"
    echo ""
    echo "# 1. Get the binaries from the maker download pages"
    echo "# 2. run the command"
    echo " dbdeployer unpack FlavorName-X.X.XX-OS.tar.gz  --prefix=FlavorName"
    echo "3. dbdeployer versions"
}

function get_prerequisites_darwin {
    echo "# 1a. Get the binaries from https://dev.mysql.com/downloads"
    echo "# or"
    echo "# 1b. Get the binaries from the MySQL fork download pages"
    echo "# run the commands:"
    echo "2a. dbdeployer unpack mysql-5.7.25-macos10.14-x86_64.tar.gz [--prefix=FlavorName]"
	echo "# or"
    echo "2b. dbdeployer unpack mysql-8.0.15-macos10.14-x86-64bit.tar.gz [--prefix=FlavorName]"
	echo "# or"
    echo "2c. dbdeployer unpack FlavorName-X.X.XX-OS.tar.gz  --prefix=FlavorName"
    echo "3. dbdeployer versions"
}

more_opts=""
if [ $found_versions != 0 ]
then
    echo "# Found versions ready to use:"
    dbdeployer versions
    echo ""
    more_opts="[MORE]"
fi

echo ""
echo "## HOW TO GET $more_opts binaries for dbdeployer "
case $os in 
linux)
    get_prerequisites_linux
    ;;
darwin)
    get_prerequisites_darwin
    ;;
*)
    echo "operating system $os not supported"
    exit 1
    ;;
esac

`

/*
var newName string = `#!/bin/bash
{{.Copyright}}
# Generated by dbdeployer {{.AppVersion}} using template {{.TemplateName}} on {{.DateTime}}
cd $(dirname $0)
source cookbook_include.sh
`
*/

var RecipesList = RecipesCollection{
	"include": RecipeTemplate{
		ScriptName:  CookbookInclude,
		Description: "common code for all recipes",
		Contents:    recipeInclude,
	},
	"single": RecipeTemplate{
		Description:  "Creation of a single sandbox",
		ScriptName:   "single-deployment.sh",
		Contents:     singleTemplate,
		IsExecutable: true,
	},
	"single-reinstall": RecipeTemplate{
		Description:  "Re-installs a single sandbox",
		ScriptName:   "single-reinstall.sh",
		Contents:     singleReinstallTemplate,
		IsExecutable: true,
	},
	"show": RecipeTemplate{
		Description:  "Show deployed sandboxes",
		ScriptName:   "show-sandboxes.sh",
		Contents:     showSandboxes,
		IsExecutable: true,
	},
	"delete": RecipeTemplate{
		Description:  "Delete all deployed sandboxes",
		ScriptName:   "delete-sandboxes.sh",
		Contents:     deleteAll,
		IsExecutable: true,
	},
	"master-slave": RecipeTemplate{
		Description:  "Creation of a master/slave replication sandbox",
		ScriptName:   "master-slave-deployment.sh",
		Contents:     masterSlaveDeployment,
		IsExecutable: true,
	},
	"fan-in": RecipeTemplate{
		Description:    "Creation of a fan-in (many masters, one slave) replication sandbox",
		ScriptName:     "fan-in-deployment.sh",
		Contents:       fanInDeployment,
		RequiredFlavor: common.MySQLFlavor,
		IsExecutable:   true,
	},
	"all-masters": RecipeTemplate{
		Description:    "Creation of an all-masters replication sandbox",
		ScriptName:     "all-masters-deployment.sh",
		Contents:       allMastersDeployment,
		RequiredFlavor: common.MySQLFlavor,
		IsExecutable:   true,
	},
	"group-multi": RecipeTemplate{
		Description:    "Creation of a multi-primary group replication sandbox",
		ScriptName:     "group-multi-primary-deployment.sh",
		Contents:       groupMultiPrimaryDeployment,
		RequiredFlavor: common.MySQLFlavor,
		IsExecutable:   true,
	},
	"group-single": RecipeTemplate{
		Description:    "Creation of a single-primary group replication sandbox",
		ScriptName:     "group-single-primary-deployment.sh",
		Contents:       groupSinglePrimaryDeployment,
		RequiredFlavor: common.MySQLFlavor,
		IsExecutable:   true,
	},
	"replication-restart": RecipeTemplate{
		Description:  "Show how to restart sandboxes with custom options",
		ScriptName:   "repl-operations-restart.sh",
		Contents:     replicationRestart,
		IsExecutable: true,
	},
	"replication-operations": RecipeTemplate{
		Description:  "Show how to run operations in a replication sandbox",
		ScriptName:   "repl-operations.sh",
		Contents:     replicationOperations,
		IsExecutable: true,
	},
	"upgrade": RecipeTemplate{
		Description:    "Shows a complete upgrade example from 5.5 to 8.0",
		ScriptName:     "upgrade.sh",
		Contents:       upgradeTemplate,
		RequiredFlavor: common.MySQLFlavor,
		IsExecutable:   true,
	},
	"tidb": RecipeTemplate{
		Description:    "Shows deployment and some operations with TiDB",
		ScriptName:     "tidb-deployment.sh",
		Contents:       tidbDeployment,
		RequiredFlavor: common.TiDbFlavor,
		IsExecutable:   true,
	},
	"ndb": RecipeTemplate{
		Description:    "Shows deployment with ndb",
		ScriptName:     "ndb-deployment.sh",
		Contents:       ndbDeployment,
		RequiredFlavor: common.NdbFlavor,
		IsExecutable:   true,
	},
	"pxc": RecipeTemplate{
		Description:    "Shows deployment with pxc",
		ScriptName:     "pxc-deployment.sh",
		Contents:       pxcDeployment,
		RequiredFlavor: common.PxcFlavor,
		IsExecutable:   true,
	},
	"remote": RecipeTemplate{
		Description:  "Shows how to get a remote MySQL tarball",
		ScriptName:   "remote.sh",
		Contents:     remoteOperations,
		IsExecutable: true,
	},
	"prerequisites": RecipeTemplate{
		Description:  "Shows dbdeployer prerequisites and how to make them",
		ScriptName:   CookbookPrerequisites,
		Contents:     prerequisites,
		IsExecutable: true,
	},
}
